#!/usr/bin/ruby
########################################################################
#
# Author: Brian Hood
# Name: Icersplicer
# Email: brianh6854@googlemail.com
#
# Description: 
#   Tool for file manipulation similar to UNIX tools
#   like cat / head / tail
#
# Why: for processing large datasets quickly.
########################################################################

require 'getoptlong' 
require 'walltime'
require 'pp'

require File.expand_path(File.join(
          File.dirname(__FILE__),
          "../lib/icersplicer.rb"))

include Icersplicer

def reset_screen
  puts "\e[0m\ "
end

def filterlinestats(filterlines)
  puts "\nLines Displayed by Filter: #{filterlines}"
end

trap("INT") {
  puts "Goodbye see you soon!"
  reset_screen
  exit
}

VERSION = Icersplicer::VERSION::STRING

ARGV[0] = "--help" if ARGV[0] == nil

opts = GetoptLong.new(
  [ '--help', '-h', GetoptLong::NO_ARGUMENT ],
  [ '--lineoffset', '-l', GetoptLong::OPTIONAL_ARGUMENT],
  [ '--linelimit', '-n', GetoptLong::REQUIRED_ARGUMENT],
  [ '--head', '-3', GetoptLong::REQUIRED_ARGUMENT],
  [ '--tail', '-4', GetoptLong::REQUIRED_ARGUMENT],
  [ '--followtail', '-5', GetoptLong::REQUIRED_ARGUMENT],
  [ '--incrementlimit', '-i', GetoptLong::OPTIONAL_ARGUMENT],
  [ '--inputfile', '-f', GetoptLong::REQUIRED_ARGUMENT],
  [ '--skiplines', '-s', GetoptLong::OPTIONAL_ARGUMENT],
  [ '--skipblank', '-b', GetoptLong::NO_ARGUMENT ],
  [ '--quiet', '-q', GetoptLong::NO_ARGUMENT],
  [ '--outputfile', '-o', GetoptLong::OPTIONAL_ARGUMENT],
  [ '--countlines', '-c', GetoptLong::OPTIONAL_ARGUMENT],
  [ '--grep', '-g', GetoptLong::REQUIRED_ARGUMENT],
  [ '--nohighlighter', '-t', GetoptLong::NO_ARGUMENT ],
  [ '--search', '-1', GetoptLong::REQUIRED_ARGUMENT],
  [ '--replace', '-2', GetoptLong::REQUIRED_ARGUMENT],
  [ '--nostats', '-6', GetoptLong::NO_ARGUMENT ],
)

opts.each do |opt, arg|
  case opt
    when '--help'
      helper = "\e[1;34mWelcome to Icersplicer #{VERSION}\e[0m\ \n"
      helper << "\e[1;34m============================\e[0m\ \n"
      helper << %Q[
-h, --help '-h':
   show help
--lineoffset '-l' INTEGER
--linelimit '-n' INTEGER
--head '-3' INTEGER
--tail '-4' INTEGER
--followtail '-5' INTEGER
--inputfile '-f' filename
--skiplines '-s' LINE NUMBERS 3,5,6
--skipblank '-b' NO ARGUMENTS ( Ommit blank lines )
--quiet '-q' NO ARGUMENTS
--outputfile '-o' filename
--countlines '-c' Counts the lines of a file
--grep '-g' Filter data
--nohighlighter '-t' NO ARGUMENTS ( Turns off syntax hightlighting )
--search '-1' Text to search for
--replace '-2' Replacement string
--nostats '-6' Don't process statistics before exit

Example:
      
      icersplicer -f inputfile --lineoffset 0 --linelimit 10 -s 3,6,9,10-15 -o outputfile
      
      TIPS: Create a custom keywords list in your #{Dir.home}/.icersplicer/keywords.ice
      
      For performant exports to an outputfile add -t as Syntax Highlighting is expensive 
      also add --quiet to make large datasets go faster / less screen output.
      
      NOTE: Quiet also disables Syntax Highlighting

Written by Brian Hood
      ]
      puts helper
      exit
    when  /^--lineoffset|^--tail/
      if opt == "--lineoffset"
        @line_offset = arg.to_i
      else
        count = countlines(@inputfile)
        @line_offset = count - arg.to_i
      end
    when /^--linelimit|^--head/
      @line_limit = arg.to_i
    when '--followtail'
      @followtail = arg.to_i
      puts "Tail lines: #{@followtail}"
    when '--incrementlimit'
      @increment_limit = arg.to_i
    when '--inputfile'
      @inputfile = arg.to_s
    when '--outputfile'
      @outputfile = arg.to_s
      puts "Outputfile: #{@outputfile}"
    when '--skiplines'
      @skip_lines = skip_processor(arg)
    when '--skipblank'
      @skipblank = "SKIP"
    when '--quiet'
      @quiet_mode = true
      @nohighlighter = "OFF"
    when '--countlines'
      @countlines = true
    when '--grep'
      @grep = arg.to_s
    when '--nohighlighter'
      @nohighlighter = "OFF"
    when '--search'
      @search = arg.to_s
    when '--replace'
      @replace = arg.to_s
    when '--nostats'
      @nostats = "SKIP"
  end
end

inputfile = @inputfile
outputfile = @outputfile
grep = @grep

if instance_variable_defined?("@followtail")
  lines = @followtail
  followtail(inputfile, lines)
end

if instance_variable_defined?("@search")
  search = @search
  if instance_variable_defined?("@replace")
    replace = @replace
    search_and_replace = true
  else
    puts "Replace string required to use search / replace features..."
    exit
  end
end

unless instance_variable_defined?("@line_offset")
  lineoffset = 0
else
  lineoffset = @line_offset
end

unless instance_variable_defined?("@line_limit") 
  linelimit = 0
else
  linelimit = @line_limit
end

increment_offset = 0
unless instance_variable_defined?("@increment_limit")
  increment_limit = 1
else
  increment_limit = @increment_limit
end
linecounter = 0
quietmode = false | @quiet_mode

if @countlines == true
  countlines(inputfile)
  exit
end

unless File.exist?("#{inputfile}")
  puts "Input filename / location doesn't exist... ?"
  exit
end

filterlines = 0
unless instance_variable_defined?("@nostats")
  timer = Stopwatch.new
  timer.watch('start')
end
begin
  File.open(inputfile) {|n|
    n.each_line {|data|
      data_orig = data.clone
      if search_and_replace == true
        data.gsub!("#{search}", "#{replace}")
      end
      unless lineoffset > increment_offset
        unless linelimit == 0
          unless increment_limit > linelimit
            unless instance_variable_defined?("@skipblank") and data_orig.strip  == ""
              if data_orig =~ /#{grep}/
                filterlines += 1
                print_to_screen(linecounter, text_processor(data), quietmode) unless skip(linecounter)
                if instance_variable_defined?("@outputfile")
                  data_orig.gsub!("#{search}", "#{replace}")
                  processdata(data_orig, outputfile, quietmode) unless skip(linecounter)
                end
              end
            end
          end
        else
          unless instance_variable_defined?("@skipblank") and data_orig.strip == ""
            if data_orig =~ /#{grep}/
              filterlines += 1
              print_to_screen(linecounter, text_processor(data), quietmode) unless skip(linecounter)
              if instance_variable_defined?("@outputfile")
                data_orig.gsub!("#{search}", "#{replace}")
                processdata(data_orig, outputfile, quietmode) unless skip(linecounter)
              end
            end
          end
        end
        increment_limit += 1
      end
      increment_offset += 1
      linecounter += 1
    }
  }
rescue Errno::EPIPE
  puts "Closing session due to broken pipe"
end
closefile
unless instance_variable_defined?("@nostats")
  filterlinestats(filterlines)
  stats(inputfile, outputfile)
  timer.watch('stop')
  timer.print_stats
end
reset_screen
